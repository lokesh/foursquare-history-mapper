<!doctype html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title></title>

  <meta name="viewport" content="width=device-width,initial-scale=1">

  <style>
    body {
      overflow: hidden;
      padding: 0;
      margin: 0;
      font: 12px "Berkeley Mono", monospace;
      color: #222;
      background: #f7f7f7;
    }

    .vue-dat-gui {
      width: 320px !important;
    }  

    .debug {
      position: fixed;
      bottom: 0;
      right: 0;
      width: 400px;
      padding: 4px;
      font-size:  12px;
      color: #f7f7f7;
      background: #222;
    }

    canvas {
      background: #ddd;
    }
  </style>

</head>
<body>

<div id="app">

  <div class="debug">
    Count: {{ places.length }}<br />
    Draw Count: {{ gridItemsCount }}<br />
    City: {{ city }}<br />
    State: {{ state }}<br />
    Country: {{ country }}<br />
    Bounding Box: {{ r(box[0].lat) }}, {{ r(box[0].lng) }} --- {{ r(box[1].lat) }}, {{ r(box[1].lng) }}<br />
    Lat height: {{ r(box[0].lat - box[1].lat) }}<br />
    Lng width: {{ r(box[1].lng - box[0].lng) }} <br />
  </div>

  <canvas id="canvas" ref="canvas"></canvas>

  <!-- <pre>
    {{ places }}
  </pre> -->

  <dat-gui>
    <dat-folder label="Places">
      <dat-number v-model="minVisitCount" label="Min visit count"></dat-number>
      <dat-select v-model="area" :items="areaSelectOptions"  label="Area" @change="onAreaChange" /></dat-folder>
      <!-- <dat-number v-model="boxTopLeft" label="Top left bound"></dat-number>
      <dat-number v-model="boxBottomRight" label="Bottom right bound"></dat-number> -->
    </dat-folder>

    <dat-folder label="Grid">
      <dat-number v-model="rows" label="Rows" :max="4800"></dat-number>
      <dat-number v-model="cols" label="Cols" :max="4800"></dat-number>
      <dat-number v-model="maxDist" label="Placement max dist" :max="20"></dat-number>
      <dat-boolean v-model="showGrid" label="Show grid"></dat-boolean>
    </dat-folder>
    <dat-folder label="Style">
      <dat-color v-model="colorBg" label="Background"></dat-color>
      <dat-color v-model="colorLabel" label="Label color"></dat-color>
    </dat-folder>
    <!-- <dat-string v-model="title" label="Title"/>
      <dat-boolean v-model="showPicture" label="Show Picture"/>
      <dat-button @click="nextPicture" label="Next picture"/>
    </dat-folder>-->
  </dat-gui>


</div>

<script src="https://unpkg.com/vue@2.6.10/dist/vue.js"></script>
<script src="https://unpkg.com/@cyrilf/vue-dat-gui@latest/dist/vue-dat-gui.umd.min.js"></script>


<script type="module">
import { Canvas } from './classes/Canvas.js';
import {
  filterByBoundingBox,
  getBoundingBox,
} from './utils/geo.js';
import { random } from './utils/math.js';


const round = (num) => Number(num).toFixed(2);

const AREA_OPTIONS = {
  'World': [{ lat: 90, lng: -180 },{ lat: -90, lng: 180 }],
  'San Francisco': [{
    lat: 37.819001,
    lng: -122.539621,
  }, {
    lat: 37.678933,
    lng: -122.344968,
  }],
  'California': {
    state: 'CA',
    country: 'United States',
  },        
  'United States': {
    country: 'United States',
  }
};

const areaSelectOptions = Object.keys(AREA_OPTIONS).map(opt => {
  return {
    name: opt,
    value: opt,
  }
});

const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 1200;

const PALETTE = [
  "#000",
];

const CATEGORY_PALETTE = {
  Arts: '#eb0054',
  Coffee: '#d90',
  Dessert: '#f39',
  Food: '#07e',
  Nightlife: '#f0c',
  Outdoors: '#090',
  Shop: '#fff',
}

const app = new Vue({
  el: '#app',

  data() {
    return {
      grid: [],
      placesUnfiltered: [],

      box: [{
        lat: 37.819001,
        lng: -122.539621,
      }, {
        lat: 37.678933,
        lng: -122.344968,
      }],

      rows: 30,
      cols: 30,
      maxDist: 2,
      showGrid: false,

      minVisitCount: 40,
      colorBg: '#fff',
      colorLabel: '#000',
      areaSelectOptions,
      area: 'San Francisco',

      city: '',
      state: '',
      country: '',

      // Helper funcs
      r: round,
    };
  },

  async created() {
    this.createGrid()
    
    const resp = await fetch('./data/places.json');
    const json = await resp.json();
    this.placesUnfiltered = json;
  },

  mounted() {
    this.canvas = new Canvas(this.$refs.canvas, CANVAS_WIDTH, CANVAS_HEIGHT);
    this.ctx = this.canvas.ctx;
  },

  watch: {
    cols() {
      this.refresh();
    },

    maxDist() {
      this.refresh();
    },

    places(val, oldVal) {
      this.refresh();
    },

    rows() {
      this.refresh();
    },

    showGrid() {
      this.refresh();
    },
  },

  computed: {
    // Debugging purposes only. Consider removing.
    gridItemsCount() {
      let count = 0;
      for (let i = 0; i < this.grid.length; i++) {
        for (let j = 0; j < this.grid[0].length; j++) {
          if (this.grid[i][j]) {
            count++;
          }
        }
      }
      return count;
    },

    latHeight() {
      return (this.box[0].lat - this.box[1].lat) / this.rows;
    },

    lngWidth() {
      return (this.box[1].lng - this.box[0].lng) / this.cols;
    },
      
    places() {
      let places = this.placesUnfiltered;
      places = this.filterByCount(places, this.minVisitCount);
      places = filterByBoundingBox(places, this.box);
      //   this.boxTopLeft,
      // });
      return places;
    },
  },

  methods: {    
    
    /**
     * Create empty grid (rows x cols)
     */
    createGrid() {
      let grid = new Array(this.rows);
      
      for (let i = 0; i < this.rows; i++) {
        grid[i] = new Array(this.cols);
      }
      
      this.grid = grid;
    },

    draw() {
      this.ctx.fillStyle = '#ddd';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      let colWidth = this.canvas.width / this.cols;
      let rowHeight = this.canvas.height / this.rows;
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          let place = this.grid[row][col];
          if (place) {
            let color = CATEGORY_PALETTE[place.category]
            this.ctx.fillStyle = color ? color : 'red';

            let x = col * colWidth;
            let y = row * rowHeight;

            // Draw box
            // console.log(place.category, this.ctx.fillStyle);
            this.ctx.fillRect(x, y, colWidth, rowHeight)

            this.ctx.font = '8px Menlo';
            this.ctx.fillStyle = '#000000';

            // let label = place.count;
            let label = place.venue.substr(0, 6);
            this.ctx.fillText(label, x, y + rowHeight);
          } else {
            this.ctx.fillStyle = '#ffffff';    
          }
        }
      }

      if (this.showGrid) {
        this.ctx.font = '8px Menlo';
        this.ctx.fillStyle = '#444';
        this.ctx.strokeStyle = '#d3d3d3';

        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.cols; col++) {
            let x = col * colWidth;
            let y = row * rowHeight;
            
            this.ctx.strokeRect(x, y, colWidth, rowHeight);
            this.ctx.fillText(`${row},${col}`, x, y + 8);
          }
        }
      }
    },

    filterByCount(places, count) {
      return places.filter(place => place.count >= count);
    },

    filterByLocale(places, city, state, country) {
      return places.filter(place => {
        if (city && place.city !== city) return false;
        if (state && place.state !== state) return false;
        if (country && place.country !== country) return false;
        return true;
      });
    },

    gridLookup(lat, lng) {
      // BUG: row val was going out of bounds. Patched a stopgap fix with Math.min()
      // let row = Math.min(Math.floor((this.box[0].lat - lat) / this.latHeight), this.rows - 1);
      let row = Math.floor((this.box[0].lat - lat) / this.latHeight);
      let col = Math.floor((lng - this.box[0].lng) / this.lngWidth);
      return [row, col];
    },

    onAreaChange(val) {
      this.box = AREA_OPTIONS[val];
      // this.city = city;
      // this.state = state;
      // this.country = country;
    },

    findNearestOpenSpot(row, col) {
      if (!this.grid[row][col]) {
        return [row, col]
      } 

      // Check boundary

      // How many concentric circles we want to expand out as
      // we search for open spots
      let i = 0;
      let foundSpot = false;

      let newRow;
      let newCol;
      
      while (i < this.maxDist && !foundSpot) {
      
      // for (let i = 0; i < MAX_RADIUS; i++) {
        let nearBySquares = [
          [row    , col - i], // left
          [row - i, col    ], // top
          [row    , col + i], // right
          [row + i, col    ], // bottom
          [row - i, col - i], // top left
          [row - i, col + i], // top right
          [row + i, col + i], // bottom right
          [row + i, col - i], // bottom left
        ]

        let a = nearBySquares.find(index => {
          newRow = index[0];
          newCol = index[1];

          if (!this.grid[newRow][newCol]) {
            foundSpot = true;
            return true;
          }
        });

        i++;
      }
      return [newRow, newCol]
    },

    /**
     * Create empty grid (rows x cols)
     */
    populateGrid() {
      this.places.forEach(place => {
        let index = this.gridLookup(place.lat, place.lng);
        let row = index[0];
        let col = index[1];

        let [ openRow, openCol ] = this.findNearestOpenSpot(row, col);
        // if (row !== openRow || col !== openCol) {
        //   console.log(`${row}, ${col}`, `${openRow - row}, ${openCol - col} <-- Diff`);
        // }
        this.grid[openRow][openCol] = place;
        

        // this.grid[row][col] = place;
        
      })

      // What about water?

      // If square is already taken, what is the closest? optionally limit how far away it can be?

    },

    refresh() {
      this.createGrid()
      this.populateGrid();
      this.draw();
    }
  }
});
</script>


  

</body>
</html>
